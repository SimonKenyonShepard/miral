import React, {Component} from 'react';

//Editors

import PredefinedColorPicker from './editors/predefinedColorPicker';
import CustomColorPicker from './editors/customColorPicker';
import CustomBorderColorPicker from './editors/customBorderColorPicker';
import BorderStyle from './editors/borderStyle';
import TextFormat from './editors/textFormat';
import FontStyle from './editors/fontStyle';
import TextAlignment from './editors/textAlignment';
import Link from './editors/link';
import DepthSetter from './editors/depthSetter';
import ElementLocker from './editors/elementLocker';
import ElementDeleter from './editors/elementDeleter';
import ElementEditorMenu from './editors/elementEditorMenu';
import Url from './editors/url';
import ElementVisibility from './editors/elementVisibility';
import ElementGroup from './editors/elementGroup';


import './styles.css';

const shapeTypeEditableFeatures = {
    "postit" : ["predefinedColor", "textFormat", "bringForward", "sendBackward", "visibility", "lock", "delete", "menu"],
    "shape" : ["customColor", "customBorderColor", "borderStyle", "fontStyle", "textFormat",  "textAlignment", "bringForward", "sendBackward", "visibility", "lock", "delete", "menu"],
    "text" : ["fontStyle", "textFormat", "textAlignment", "bringForward", "sendBackward", "visibility", "lock", "delete", "menu"],
    "line" : ["customBorderColor", "borderStyle", "bringForward", "sendBackward", "lock", "delete", "menu"],
    "image" : ["url", "customBorderColor", "borderStyle", "bringForward", "sendBackward", "visibility", "lock", "delete", "menu"],
    "slide" : ["customColor", "bringForward", "sendBackward", "lock", "delete", "menu"],
    "link" : ["link", "visibility", "lock", "delete", "menu"],
    "youtube" : ["url", "lock", "delete", "menu"],
    "emoji" : [ "visibility", "lock", "delete", "menu"]
};

const multiElementEditableFeatures = ["bringForward", "sendBackward", "lock", "group", "delete", "menu"];

class ElementEditor extends Component {

    constructor(props, context) {
      super(props, context);
      this.state = {
        currentOpenSubMenu : null
      };
    }

    handleUpdateElementProperty = (data) => {
        data.id = this.props.selectedElements.map((element) => element.id);
        this.props.handleUpdateElementProperty(data);
    }

    handleSetCurrentOpenSubMenu = (currentOpenSubMenu) => {
        this.setState({currentOpenSubMenu});
    }

    shouldComponentUpdate(nextProps) {
        const shouldUpdate = (this.props.selectedElements.length !== nextProps.selectedElements.length) || (nextProps.selectedElements.length > 0);
        if(shouldUpdate) {
            return true;
        } else {
            return false;
        }
    }

    handleKeyPress = (e) => {
        
        const isTextBox = this.props.textEditor !== null || e.target.tagName === "INPUT" || e.target.getAttribute("contentEditable") === "true";
        if(e.key === "Backspace" && !isTextBox) {
            e.preventDefault();
            this.handleDeleteElements();
        } else if(
            (e.ctrlKey === true && e.key === "d") ||
            (e.metaKey === true && e.key === "d")
        ) {
            e.preventDefault();
            this.handleDuplicateElements();
        }
        
    }

    render() {
        const containerPosition = {},
            {
                selectedElements,
                boundingBox,
                getSlides
            } = this.props;
        let containerClass = "elementEditor",
            editButtonTypes = null,
            editButtons = null;
        
        const selectedIDs = selectedElements.map(element => {
            return element.id;
        });
        
        if(selectedElements.length === 1) {
            editButtonTypes = shapeTypeEditableFeatures[selectedElements[0].type];
        } else if (selectedElements.length > 1) {
            editButtonTypes = [...multiElementEditableFeatures];
            let areAllShapes = true;
            selectedElements.forEach(element => {
                if(element.type !== "shape") {
                    areAllShapes = false;
                }
            });
            if(areAllShapes) {
                editButtonTypes.unshift("customColor");
            }
        }
        if(editButtonTypes) {
            editButtons = editButtonTypes.map(button => {
                switch (button) {
                    case 'predefinedColor':
                        return <PredefinedColorPicker 
                                    key={`${selectedElements[0].id}_${button}`}
                                    fillColor={selectedElements[0].predefinedColor}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'customColor':
                        return <CustomColorPicker 
                                    key={`${selectedElements[0].id}_${button}`}
                                    currentStyles={selectedElements}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'customBorderColor':
                        return <CustomBorderColorPicker 
                                    key={`${selectedElements[0].id}_${button}`}
                                    currentStyles={selectedElements[0].styles}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'borderStyle':
                        return <BorderStyle 
                                    key={`${selectedElements[0].id}_${button}`}
                                    currentStyles={selectedElements[0].styles}
                                    initialZoomLevel={selectedElements[0].initialZoomLevel}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'textFormat':
                    return <TextFormat 
                                key={`${selectedElements[0].id}_${button}`}
                                fontStyle={selectedElements[0].fontStyle}
                                initialZoomLevel={selectedElements[0].initialZoomLevel}
                                handleUpdateElementProperty={this.handleUpdateElementProperty}
                                handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                currentOpenSubMenu={this.state.currentOpenSubMenu}
                            />;
                    case 'fontStyle':
                        return <FontStyle 
                                    key={`${selectedElements[0].id}_${button}`}
                                    fontStyle={selectedElements[0].fontStyle}
                                    initialZoomLevel={selectedElements[0].initialZoomLevel}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'textAlignment':
                        return <TextAlignment 
                                    key={`${selectedElements[0].id}_${button}`}
                                    fontStyle={selectedElements[0].fontStyle}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'link':
                        return <Link 
                                    key={`${selectedElements[0].id}_${button}`}
                                    link={selectedElements[0].link}
                                    getSlides={getSlides}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'bringForward':
                        return <DepthSetter 
                                    type="forward" 
                                    key={`${selectedElements[0].id}_${button}`}
                                    handleShiftElementPosition={this.props.handleShiftElementPosition}
                                    ids={selectedIDs}
                                />;
                    case 'sendBackward':
                        return <DepthSetter 
                                    type="backward" 
                                    key={`${selectedElements[0].id}_${button}`}
                                    handleShiftElementPosition={this.props.handleShiftElementPosition}
                                    ids={selectedIDs}
                                />;
                    case 'group':
                        return <ElementGroup 
                            key={`${selectedElements[0].id}_${button}`}
                            elements={selectedElements}
                            handleUpdateElementProperty={this.handleUpdateElementProperty}
                        />;
                    case 'visibility':
                        return <ElementVisibility 
                            key={`${selectedElements[0].id}_${button}`}
                            isHidden={selectedElements[0].hidden}
                            handleUpdateElementProperty={this.handleUpdateElementProperty}
                        />;
                    case 'lock':
                        return <ElementLocker 
                                    key={`${selectedElements[0].id}_${button}`} 
                                    isLocked={selectedElements[0].locked}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                />;
                    case 'delete':
                        return <ElementDeleter 
                                    key={`${selectedElements[0].id}_${button}`} 
                                    handleDeleteElements={this.props.handleDeleteElements}
                                />;
                    case 'url':
                        return <Url 
                                    key={`${selectedElements[0].id}_${button}`}
                                    URL={selectedElements[0].URL}
                                    handleUpdateElementProperty={this.handleUpdateElementProperty}
                                    handleSetCurrentOpenSubMenu={this.handleSetCurrentOpenSubMenu}
                                    currentOpenSubMenu={this.state.currentOpenSubMenu}
                                />;
                    case 'menu':
                        return <ElementEditorMenu options={shapeTypeEditableFeatures[selectedElements[0].type]} key={`${selectedElements[0].id}_${button}`} />;
                    default:
                      return null;
                  }
            });
            
            containerClass += " isVisible";

            const editorHeightPlusMargin = 40+56,
                  halfEditorWidth = (editButtons.length*40)/2,
                  halfElementWidth = boundingBox.width/2,
                  finalLeft = (boundingBox.x+halfElementWidth)-halfEditorWidth,
                  finalTop = boundingBox.y-editorHeightPlusMargin;

            containerPosition.left = `${finalLeft}px`;
            containerPosition.top = `${finalTop}px`;

        }
        
        return (
            <div className={containerClass} style={containerPosition}>
               {editButtons}
            </div>
        );
    }

    
  }

  export default ElementEditor;